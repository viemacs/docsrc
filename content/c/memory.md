---
weight: 20
title: C
---

## Memory

### 内存分配方式中的 栈、堆、自由存储区、全局与静态存储区、常量存储区
- 栈  
    栈是由编译器管理的变量存储区，在需要时分配，在不需要时自动释放。用户栈位于用户进程地址空间的顶部，在执行期间可以**动态地扩展和收缩**。栈中的变量有局部变量、函数参数，编译器也会用栈来实现函数调用。

- 堆  
    堆是由用户程序主动管理的内存块，编译器不做管理。堆上的内存用 new 分配，用 delete 释放。没有释放的内存在用户程序结束后由操作系统回收。堆可以*动态地扩展和收缩*。

- 自由存储区  
    自由存储区和堆相似。自由存储区的内存用 malloc 分配，用 free 释放。

- 全局与静态存储区  
    全局变量和静态变量的内存存储区。在 C++ 中为一块内存区。在 C 中，静态变量和初始化的全局变量在一块内存区，未初始化的全局变量在相邻的内存区。可通过 void* 来操作未初始化变量的存储区。全局和静态变量都在程序结束时由系统进行释放。

- 常量存储区  
    常量存储，不允许修改其中的变量。

### 堆栈的区别
堆和栈的区别是大家常说起的一个问题。

```c++
#include <stdlib.h>
int main() {
    int* a = (int*) malloc(4);
    free(a);
    return 0;
}
```
指针 a 在栈上分配了一段内存，malloc 在堆上分配了一段4个整型大小的内存，然后把这段内存的首地址返回给指针 a。

堆和栈的区别主要有5点。（中文中“堆栈”指栈。）

1. 管理方式  
    栈由编译器自动管理；堆由用户程序主动管理，显示进行分配和释放。
    
2. 空间大小  
    栈一般有一定的空间大小，而且默认的空间大小较小，例如1M；而堆在32位系统下的地址空间就可以达到4G。
    
3. 碎片  
    栈是 FILO 队列，永远不会从中间 pop 内存块。而堆在大量的 malloc/free, new/delete 内存空间会产生许多的不连续，生成内存碎片。

4. 分配方向  
    堆地址的分配是从小往大，向着内存地址增加的方向进行；栈地址的分配是从大往小，向内存地址减小的方向进行。

5. 分配方式 **这部分解释有问题**  
    栈的静态分配由编译器完成。堆是动态分配的，没有静态分配。
    栈的动态分配，使用 malloc，但由编译器进行释放。

6. 分配效率  
    栈比堆的效率更高。栈在系统层有更多的支持，有专门的指令进行压栈和出栈，有专门的寄存器存放栈地址。堆由函数库提供支持。
    在堆上分配一块内存时，库函数会按照特定算法在堆中查找足够大小的可用空间，如果由碎片过多等原因没有足够大小的空间，则调用系统功能去增加程序数据段的空间，以产生足够大小的内存。

和栈相比，堆没有专门的系统层支持，可能引发用户态和核心态的切换（**什么意思**）使内存申请的代价更大，大量的分配和释放操作后容易产生大量内存碎片。在效率更重要的地方，比如函数调用，是利用栈来完成的。函数调用中的参数，返回地址，EBP，局部变量都由栈来存放。而堆比栈更灵活（**怎么灵活的**），在分配大量内存空间时，优先使用堆。

堆和栈都是对存空间的操作，要防止内存越界问题。内存越界会使程序产生意外的结果，或使程序崩溃。
