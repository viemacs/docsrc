---
weight: 20
title: JS
---

## JS Development Environment

随着前端和 Node.JS 的发展, 以及页面的APP化, JS 成为开发应用的不错的选择.
前后通吃, 语法灵活, 发展迅速, 对提高开发效率很有帮助.

JS 开发发展迅速带来的一个问题是工具和库众多, 开发中选择什么工具成了一个问题.
我从两年前真正开始写JS开始尝试了一些工具和库, 试过之后才知道什么更适合自己.

### 编辑器
单就文本编辑器而言, 当然还是首推 Emacs 和 Vim. 除这两者之外, 还有许多不错和编辑器和IDE.

- Sublime 比较灵活, 有插件, 可配置. 上手容易, 但要用上各种插件有点繁.
- Atom 比较适合前端技术栈, github 出品, 应该不错. 没真正用过.
- Brackets 使用时感觉很方便, web 预览功能很不错. 当时版本较早, 有一些bug, 现在应该更好用了.
- WebStorm 完整的 IDE 的样子, 对 JS 开发非常不错, 前端, Node.JS, git 都支持, 也有 emacs 模式. 用习惯之后对生产效率应该会有提升.

### 打包
打包包括了开发上线所需的预编译, 压缩, 转换, 优化, 构建任务.

现在使用的是 Webpack. 既然 Webpack 有丰富的loader, 方便的 API, 良好的生态环境, 为什么不用它呢?

由于接触JS工程比较晚, 有 Webpack 可用, 对早期的 Grunt 和后来的 Gulp 并不了解.
大家似乎是觉得 Grunt 配置麻烦, 效率不高, 于是转向 Gulp.
还有就是使用 NPM 的构建方式, 我不怎么会用, 感觉和上面三种打包工具不属一类工具.
在自己的工程中尝试使用过 Grunt 和 Gulp, 由于工程较小, 使用起来并没有感觉方便.
在压缩js, 分发文件方面, 比自己写 Python 脚本更复杂.

Grunt 要完成配置之后, 在日常开发中, 通过一个命令就能自动完成文件合并压缩, 上线构建, 在线重载(live-reload).
在项目变得复杂之后, 仅靠配置难以满足需求, 只有增加插件配置项. 而越来越多的配置项使得Grunt的配置变得过于麻烦.

Gulp 则是提供类 Linux 的文件流操作, 以编程的方式组建任务, 来解决越来越多的配置项的问题.


----
### webpack + vue 心得
(ref: wechat 医小生与程序猿 (doctor_programmer))

1. **要单页面还是多页面**。我们的项目比较大，目录又多又深，如果用配合vue-router做成整体的单页面应用，必然会因多级嵌套路由而造成各种困扰。所以最终决定一个功能模块一个页面，各模块自己做成SPA。这个方案也为后面进行多入口打包带来了麻烦。

2. **公共框架如何处理。**  所谓公共框架就是像vue、jquery、bootstrap这的第三方框架。 它们基本不会改动，所以肯定是要单独打成一个包的，充分利用缓存。另外一个问题就是，这些框架的代码放哪里好，有人用bower管理，有人用npm管理，或者是像我们之前那样在项目中放一个lib目录，下载好框架代码后就放进去不动了。不过现在业界普遍都推commonjs规范了，所以用npm来管理是个趋势。

3. **项目的公用组件如何打包。**  既然是用vue，那肯定会写很多公共的组件了，这些组件肯定不能和第三方库打包到一起，也不要和业务代码打包在一起，因为业务代码总改动，而公共组件相对改动也比较少。最好是把所有的组件打成一个包。然而webpack的设计思想并不是这样，它是完全按照模块的依赖树来分析，根据依赖进行打包。我们的组件之间如果没有依赖，是没法打到一起的。

4. **CommonsChunkPlugin的硬伤。**  关于公用组件的处理，其实可以用CommonsChunkPlugin这个插件，它能自动分析出公共模块并打成一个包。但是这个插件有个硬伤，如果我写了一个名为popbox的组件，本意是想给项目公用，但是目前只有一个模块用到了它，那么插件并不能知道它是公用插件，而会把它和业务代码打包到一起。倘若将来有第二个模块用到了popbox，就又会把它打进公共包里，这显然是很弱智的行为。

5. **entry只干入口的事。**  我一开始想，把公共组件放entry中打包一下行不行，像这样配置：`components: ['loading', 'menu', 'box']`。结果证明是不能的，文件虽然能打包出来，但是没法用，就是你`<script>`标签把文件加到页面也不行，别的模块用require无法引用到。原因就是entry打包出的文件作为入口文件，必须包含直接运行的代码。

6. **webpack-stream是个鸡肋。**  一开始我被entry和output的各种配置整的摸不着头脑，因为项目目录多，想要更精细的控制，却发现output总是无法按我的需求输出。后来我看到了有webpack-stream这个东西，而且是官方推荐的。简单来讲，它就是实现了文件流接口，从而能与gulp配合工作，我一看这是个好东西啊。研究了一番，发现也没什么功能，就是能用gulp.src代替entry，用gulp.dest代替output，对于多入口打包，就完全没什么用了，还得在webpack中配置，所以简直就是个鸡肋。直接弃用。

7. **这么多require用哪个。**  一开始用webpack构建应用的时候，每当写require的时候我是懵逼的，有commonjs风格的require用法、AMD风格的require加回调用法，以及webpack提供的require.ensure用来打包异步加载的模块。另外还有ES6的import，既然都用vue了，我们肯定得用ES6嘛。这么多引入模块的方法，你得保持头脑清醒了，他们都有什么区别，什么场景下用哪个。

8. **dist目录不是给人看的。**  鉴于之前用gulp的习惯，打包后的目录也是有很清晰的结构，而且打包前我们src目录下的代码也是直接可运行的。但是有了webpack之后，首先src下的代码未经打包不能在开发环境运行，其次output选项只能指定一个输出目录，无法再按你的想法再进行组织。唯一有点用的方法是在entry中，把入口文件名字写成这样foo/bar/baz。勉强能在输出目录中新建出文件夹。但是总体来看，dist目录还是一团糟，尤其是异步的chunk文件，只能是id+hash这样的名字。所以我也明白了，要用webpack就别打算去看dist目录了，只能用sourcemap在浏览器看。
