---
title: Design
weight: 20
---

## Reactive System

### 响应式系统，响应式编程
事件驱动实现响应式编程，消息驱动实现响应式系统。

响应式编程强调的是数据流而非控制流。

例子：

- Futures / Promises：值的容器，many-read and single-write
- 响应式 流：无限制的数据处理流，支持异步，非阻塞，多个源与目的
- 反压转换管道 Back-pressure transformation pipelines
- 数据流变量：依赖于输入，过程procedures 或其他单元的 单赋值变量（存储单元）single assignment variables，能够自动更新值的改变。如：表格软件中一个单元格值的改变会影响到所有依赖于它的函数，顺流而下地使它们产生新的值。
    
JVM 中支持 非阻塞式反压异步流，响应式编程 的流行库有：Akka Streams, Ratpack, Reactor, ExJava, Vert.x

响应式编程的基本好处是：提高多核和多 CPU 硬件的计算资源利用率；通过减少序列化点来提高性能（阿姆达尔定律，古瑟通用可伸缩定律 Amdahl, Guenther）。

响应式编程中，active 活动组件间一般不需要明确的协作，而避开了传统的编程范式的做法：尽力提供一个简单直接的可持续的方法来处理异步非阻塞计算和 I/O。

响应式编程的价值在于组件的创建和工作流的组合。在异步执行上加入**反压**以避免过度使用/无限度地消耗资源。

为在更高层次上理清一个系统，设计响应式系统，需要为其设计响应式架构。响应式编程仅是一种编程范式，要注意它的适用条件和情形。

1. 事件驱动与消息驱动
    
    响应式编程的着眼点在短时数据流链条上的计算，因而使用事件驱动；响应式系统关注于通过分布式系统的通信和协作所得到的弹性和韧性，使用消息驱动 messaging。
    
    事件驱动的数据流驱动模型，拥有 long-live addressable 长期存活可寻址 组件的消息驱动系统，两者的不同在于，消息具有固定的导向，事件没有；消息会有一个明确的去向，而事件只是一个等待被观察的信息。消息式结构更适用于异步，因为消息的发送与接收和发送者与接收者是分离的。

    > 一条消息就是一则被送往一个明确目的地的数据。一个事件则是达到某个给定状态的组件发出的一个信号。在一个消息驱动的系统中，可寻址到的接收者等待消息的到来然后响应它，否则保持休眠状态。在一个事件驱动系统中，通知的监听者被绑定到消息源上，这样当消息被发出时它就会被调用。这意味着一个事件驱动系统专注于可寻址的事件源，而消息驱动系统专注于可寻址的接收者。

    分布式系统需要通过消息在网络上传输进行交流，以实现其沟通基础，而事件的发出则是本地的。常见的做法是在底层通过发送包裹着事件的消息来搭建跨网络的事件驱动系统，这样能维持在分布式环境下事件驱动编程模型的相对简易，可以用在合理范围内的特殊案例上。
    
    分布式环境下的事件驱动在编程模型的抽象性和简易性上有好处，但在控制性上有欠缺。消息强迫我们去拥抱分布式系统的真实性和一致性。你需要去考虑局部错误，错误侦测，丢弃/复制/重排序消息 （partial failures, failure detection, dropped/duplicated/reordered），还有一致性问题，管理多个并发真实性（并发真实性？）。你需要面对它们，处理它们，而不是藏在低劣的抽象层后，假装网络并不存在，像是 EJB, RPC, CORBA, XA。
    
    在设计中，这种语义和适用性上的不同对应用有深刻的影响，包括分布式系统的复杂性中的弹性，韧性，移动性，位置透明和管理。
    
    在使用了响应式编程技术的响应式系统中，有用于沟通的消息，也不呈现现实的事件。

2. 响应式系统

3. 响应式程序与系统

4. 弹性

5. 韧性

6. 生产效率

7. 编程与系统关联

8. 总结

----
流，轻量，**实时**

分布式环境下，实现技术，工具，设计模式

SCALE, 负载平衡，**主动执行**

FRP（FP） is misused

RP，由有效信息推动，而非执行流程/线程推动的控制流。信息实现异步非阻塞与 IO 非绑定。
